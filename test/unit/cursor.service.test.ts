import { CursorService } from '../../src/services/cursor';
import { TemplateManager } from '../../src/services/template-manager';
import { FileSystemService } from '../../src/services/filesystem';
import { promises as fs } from 'fs';
import * as path from 'path';
import * as os from 'os';
import { describe, expect, beforeEach, it, jest } from '@jest/globals';

// Mock dependencies
jest.mock('fs', () => ({
  promises: {
    access: jest.fn(),
    readFile: jest.fn(),
    writeFile: jest.fn(),
    mkdir: jest.fn(),
    stat: jest.fn(),
    copyFile: jest.fn(),
    readdir: jest.fn(),
  },
}));

jest.mock('os');

// Create typed mocks
const mockFs = fs as jest.Mocked<typeof fs>;
const mockOs = os as jest.Mocked<typeof os>;

describe('CursorService', () => {
  let cursorService: CursorService;
  let mockTemplateManager: jest.Mocked<TemplateManager>;
  let mockFileSystemService: jest.Mocked<FileSystemService>;
  let tempDir: string;

  beforeEach(() => {
    tempDir = '/tmp/test-project';

    mockTemplateManager = {
      getTemplateFiles: jest.fn(),
      generateTemplate: jest.fn(),
      validateTemplate: jest.fn(),
      getInstructionFiles: jest.fn(),
    } as any;

    mockFileSystemService = {
      ensureDirectoryExists: jest.fn(),
      writeFile: jest.fn(),
      readFile: jest.fn(),
      fileExists: jest.fn(),
      copyFile: jest.fn(),
      backupFile: jest.fn(),
      listFiles: jest.fn(),
    } as any;

    cursorService = new CursorService(
      mockTemplateManager,
      mockFileSystemService
    );

    // Reset all mocks
    jest.clearAllMocks();
  });

  describe('Cursor IDE Detection and Validation', () => {
    it('CUR-UNIT-001: Should detect if Cursor IDE is installed on the system', async () => {
      // Mock successful access to cursor config directory
      const mockHomedir = '/Users/testuser';
      mockOs.homedir.mockReturnValue(mockHomedir);
      mockFs.access.mockResolvedValue(void 0);

      const isInstalled = await cursorService.detectCursorIDE();

      expect(isInstalled).toBe(true);
      expect(mockFs.access).toHaveBeenCalledWith(
        path.join(mockHomedir, '.cursor')
      );
    });

    it('CUR-UNIT-002: Should return false when Cursor IDE is not installed', async () => {
      // Mock failed access to cursor config directory
      const mockHomedir = '/Users/testuser';
      mockOs.homedir.mockReturnValue(mockHomedir);
      mockFs.access.mockRejectedValue(new Error('ENOENT'));

      const isInstalled = await cursorService.detectCursorIDE();

      expect(isInstalled).toBe(false);
    });

    it('CUR-UNIT-003: Should validate that Cursor version supports .cursorrules', async () => {
      // Mock cursor being detected and supporting rules
      const mockHomedir = '/Users/testuser';
      mockOs.homedir.mockReturnValue(mockHomedir);
      mockFs.access.mockResolvedValue(void 0);

      const isCompatible = await cursorService.validateCursorCompatibility();

      expect(isCompatible).toBe(true);
    });

    it('CUR-UNIT-004: Should return correct Cursor configuration directory path', () => {
      const mockHomedir = '/Users/testuser';
      (os.homedir as jest.Mock).mockReturnValue(mockHomedir);

      const configPath = cursorService.getCursorConfigPath();

      expect(configPath).toBe(path.join(mockHomedir, '.cursor'));
    });

    it('CUR-UNIT-005: Should handle custom Cursor config paths', () => {
      const customPath = '/custom/cursor/config';

      const configPath = cursorService.getCursorConfigPath(customPath);

      expect(configPath).toBe(customPath);
    });
  });

  describe('Cursor Rules File Management', () => {
    it('CUR-UNIT-006: Should generate workflow.cursorrules content from instruction templates', async () => {
      const mockInstructionContent = `# Test Instructions\n\nThis is a test instruction file.`;
      mockTemplateManager.getInstructionFiles.mockResolvedValue([
        { path: 'copilot-instructions.md', content: mockInstructionContent },
      ]);

      const workflowRules = await cursorService.generateWorkflowRules(
        tempDir,
        'typescript'
      );

      expect(workflowRules).toContain('Test Instructions');
      expect(workflowRules).toContain('Generated by metacoding');
      expect(mockTemplateManager.getInstructionFiles).toHaveBeenCalledWith(
        'typescript'
      );
    });

    it('CUR-UNIT-007: Should generate pattern-specific .cursor/rules/*.mdc files', async () => {
      const mockLanguageInstructions = [
        {
          path: 'typescript.coding.instructions.md',
          content: '# TypeScript Rules',
        },
        { path: 'test-runner.instructions.md', content: '# Test Rules' },
      ];
      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        mockLanguageInstructions
      );

      const patternRules = await cursorService.generatePatternRules(
        tempDir,
        'typescript'
      );

      expect(patternRules).toHaveLength(2);
      expect(patternRules[0]).toMatchObject({
        filename: expect.stringMatching(/typescript.*\.mdc$/),
        content: expect.stringContaining('TypeScript Rules'),
        pattern: '**/*.ts',
      });
      expect(patternRules[1]).toMatchObject({
        filename: expect.stringMatching(/test.*\.mdc$/),
        content: expect.stringContaining('Test Rules'),
        pattern: '**/*.test.ts',
      });
    });

    it('CUR-UNIT-008: Should safely install rules files without overwriting existing files', async () => {
      const workflowContent = 'Generated workflow rules';
      const patternRules = [
        { filename: 'typescript.mdc', content: 'TS rules', pattern: '**/*.ts' },
      ];

      mockFileSystemService.fileExists.mockResolvedValue(false);
      mockFileSystemService.ensureDirectoryExists.mockResolvedValue();
      mockFileSystemService.writeFile.mockResolvedValue();

      const result = await cursorService.installCursorRules(
        tempDir,
        workflowContent,
        patternRules
      );

      expect(result.success).toBe(true);
      expect(result.conflicts).toHaveLength(0);
      expect(mockFileSystemService.writeFile).toHaveBeenCalledWith(
        path.join(tempDir, '.cursor', 'rules', 'workflow.mdc'),
        expect.stringContaining(workflowContent)
      );
      expect(mockFileSystemService.writeFile).toHaveBeenCalledWith(
        path.join(tempDir, '.cursor', 'rules', 'typescript.mdc'),
        patternRules[0]?.content
      );
    });

    it('CUR-UNIT-009: Should detect conflicts with existing .cursor/rules files', async () => {
      const workflowContent = 'Generated workflow rules';
      const patternRules: any[] = [];

      // Mock existing workflow.mdc file in .cursor/rules
      mockFileSystemService.fileExists.mockImplementation(
        (filePath: string) => {
          return Promise.resolve(
            filePath.includes('.cursor/rules/workflow.mdc')
          );
        }
      );

      const result = await cursorService.installCursorRules(
        tempDir,
        workflowContent,
        patternRules
      );

      expect(result.success).toBe(false);
      expect(result.conflicts).toContain('.cursor/rules/workflow.mdc');
    });

    it('CUR-UNIT-010: Should create backups of existing Cursor rules files', async () => {
      const existingRulesPath = path.join(
        tempDir,
        '.cursor',
        'rules',
        'workflow.mdc'
      );
      const cursorRulesDir = path.join(tempDir, '.cursor', 'rules');
      const legacyWorkflowPath = path.join(tempDir, 'workflow.cursorrules');
      const backupPath = `${existingRulesPath}.backup.${Date.now()}`;

      // Mock specific file existence checks
      mockFileSystemService.fileExists.mockImplementation(
        async (filePath: string) => {
          if (filePath === legacyWorkflowPath) return false; // No legacy file
          if (filePath === cursorRulesDir) return true; // .cursor/rules directory exists
          return false;
        }
      );

      mockFileSystemService.listFiles.mockResolvedValue([
        'rule1.mdc',
        'rule2.mdc',
        'workflow.mdc',
      ]);
      mockFileSystemService.backupFile.mockResolvedValue(backupPath);

      const result = await cursorService.backupExistingRules(tempDir);

      expect(result.length).toBe(3); // 3 .mdc files
      expect(mockFileSystemService.backupFile).toHaveBeenCalledWith(
        path.join(cursorRulesDir, 'rule1.mdc')
      );
      expect(mockFileSystemService.backupFile).toHaveBeenCalledWith(
        path.join(cursorRulesDir, 'rule2.mdc')
      );
      expect(mockFileSystemService.backupFile).toHaveBeenCalledWith(
        path.join(cursorRulesDir, 'workflow.mdc')
      );
      expect(mockFileSystemService.listFiles).toHaveBeenCalledWith(
        cursorRulesDir
      );
    });
  });

  describe('Template Content Processing', () => {
    it('CUR-UNIT-011: Should convert Copilot instructions to Cursor rules format', () => {
      const copilotInstructions = `# Copilot Instructions\n\nUse TypeScript best practices.`;

      const cursorRules =
        cursorService.processInstructionTemplate(copilotInstructions);

      expect(cursorRules).toContain('# Cursor AI Development Rules');
      expect(cursorRules).toContain('Use TypeScript best practices.');
      expect(cursorRules).toContain('Generated by metacoding');
    });

    it('CUR-UNIT-012: Should combine multiple instruction files into workflow.cursorrules', () => {
      const instructionFiles = [
        {
          path: 'copilot-instructions.md',
          content: '# Main Instructions\nCore rules.',
        },
        {
          path: 'typescript.coding.instructions.md',
          content: '# TypeScript\nTS rules.',
        },
      ];

      const merged = cursorService.mergeInstructionFiles(instructionFiles);

      expect(merged).toContain('Main Instructions');
      expect(merged).toContain('Core rules.');
      expect(merged).toContain('TypeScript');
      expect(merged).toContain('TS rules.');
    });

    it('CUR-UNIT-013: Should extract pattern-specific rules for .mdc files', () => {
      const instructionFile = {
        path: 'typescript.coding.instructions.md',
        content: '# TypeScript Rules\nUse strict typing.',
      };

      const mdcFile = cursorService.extractPatternSpecificRules(
        instructionFile,
        '**/*.ts'
      );

      expect(mdcFile.pattern).toBe('**/*.ts');
      expect(mdcFile.content).toContain('TypeScript Rules');
      expect(mdcFile.content).toContain('Use strict typing.');
      expect(mdcFile.filename).toMatch(/typescript.*\.mdc$/);
    });

    it('CUR-UNIT-014: Should validate generated rules content for Cursor compatibility', () => {
      const validRules = '# Valid Cursor Rules\nUse TypeScript.';
      const invalidRules = '<!-- Invalid HTML content -->';

      expect(cursorService.validateRulesContent(validRules)).toBe(true);
      expect(cursorService.validateRulesContent(invalidRules)).toBe(false);
    });
  });

  describe('Error Handling and Edge Cases', () => {
    it('CUR-UNIT-015: Should handle corrupted instruction files gracefully', async () => {
      mockTemplateManager.getInstructionFiles.mockRejectedValue(
        new Error('Corrupted template file')
      );

      await expect(
        cursorService.generateWorkflowRules(tempDir, 'typescript')
      ).rejects.toThrow('Corrupted template file');
    });

    it('CUR-UNIT-016: Should handle file permission errors during installation', async () => {
      const workflowContent = 'Generated workflow rules';
      const patternRules: any[] = [];

      mockFileSystemService.fileExists.mockResolvedValue(false);
      mockFileSystemService.writeFile.mockRejectedValue(
        new Error('EACCES: permission denied')
      );

      await expect(
        cursorService.installCursorRules(tempDir, workflowContent, patternRules)
      ).rejects.toThrow('EACCES: permission denied');
    });

    it('CUR-UNIT-017: Should handle missing template directory', async () => {
      mockTemplateManager.getInstructionFiles.mockResolvedValue([]);

      const workflowRules = await cursorService.generateWorkflowRules(
        tempDir,
        'nonexistent'
      );

      expect(workflowRules).toContain('Generated by metacoding');
      expect(workflowRules).toContain('No specific instructions found');
    });
  });
});
