import { CursorService, PatternRule } from '../../src/services/cursor';
import { TemplateManager } from '../../src/services/template-manager';
import { FileSystemService } from '../../src/services/filesystem';
import * as path from 'path';
import * as os from 'os';
import { describe, test, expect, beforeEach, jest } from '@jest/globals';

describe('CursorService - File Generation Logic (Phase 3)', () => {
  let cursorService: CursorService;
  let mockTemplateManager: jest.Mocked<TemplateManager>;
  let mockFileSystemService: jest.Mocked<FileSystemService>;

  beforeEach(() => {
    mockTemplateManager = {
      getInstructionFiles: jest.fn(),
    } as any;

    mockFileSystemService = {
      fileExists: jest.fn(),
      writeFile: jest.fn(),
      ensureDirectoryExists: jest.fn(),
      backupFile: jest.fn(),
    } as any;

    cursorService = new CursorService(
      mockTemplateManager,
      mockFileSystemService
    );
  });

  describe('Workflow Rules Generation', () => {
    test('CUR-GEN-001: Should create workflow.cursorrules from copilot-instructions.md', async () => {
      const instructionFiles = [
        {
          path: 'templates/general/copilot-instructions.md',
          content: `# GitHub Copilot Instructions

These are development guidelines for GitHub Copilot.

## Code Quality
- Write clean, maintainable code
- Follow TypeScript best practices`,
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generateWorkflowRules(
        '/test/project',
        'general'
      );

      expect(result).toContain('Generated by metacoding v');
      expect(result).toContain('Cursor AI Development Rules');
      expect(result).toContain('# Cursor AI Instructions');
      expect(result).toContain('Write clean, maintainable code');
      expect(result).toContain(
        'Source: templates/general/copilot-instructions.md'
      );
    });

    test('CUR-GEN-002: Should include metacoding version and source attribution', async () => {
      const instructionFiles = [
        {
          path: 'templates/node/copilot-instructions.md',
          content: 'Test instructions',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generateWorkflowRules(
        '/test/project',
        'node'
      );

      expect(result).toMatch(/Generated by metacoding v\d+\.\d+\.\d+/);
      expect(result).toContain(
        'Source: templates/node/copilot-instructions.md'
      );
      expect(result).toContain(
        'Do not edit manually - regenerate using metacoding update'
      );
    });

    test('CUR-GEN-003: Should preserve markdown structure', async () => {
      const instructionFiles = [
        {
          path: 'templates/general/copilot-instructions.md',
          content: `# Main Title

## Section 1
Content with **bold** and *italic* text.

### Subsection
- List item 1
- List item 2

\`\`\`typescript
function example() {
  return 'code';
}
\`\`\``,
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generateWorkflowRules(
        '/test/project',
        'general'
      );

      expect(result).toContain('# Main Title');
      expect(result).toContain('## Section 1');
      expect(result).toContain('### Subsection');
      expect(result).toContain('**bold**');
      expect(result).toContain('*italic*');
      expect(result).toContain('- List item 1');
      expect(result).toContain('```typescript');
      expect(result).toContain("return 'code';");
    });

    test('CUR-GEN-004: Should generate minimal valid rules for empty instructions', async () => {
      mockTemplateManager.getInstructionFiles.mockResolvedValue([]);

      const result = await cursorService.generateWorkflowRules(
        '/test/project',
        'general'
      );

      expect(result).toContain('Generated by metacoding v');
      expect(result).toContain('# Default Cursor AI Rules');
      expect(result).toContain('No specific instructions found');
      expect(result).toContain('general best practices');
    });

    test('CUR-GEN-005: Should validate workflow rules content', async () => {
      const validContent = `# Cursor AI Rules
      
This is valid markdown content for Cursor AI.`;

      const invalidContent = `<!-- HTML comments not allowed -->
<script>alert('bad')</script>`;

      expect(cursorService.validateRulesContent(validContent)).toBe(true);
      expect(cursorService.validateRulesContent(invalidContent)).toBe(false);
      expect(cursorService.validateRulesContent('')).toBe(false);
      expect(cursorService.validateRulesContent('   ')).toBe(false);
    });
  });

  describe('Pattern-Specific Rule Generation', () => {
    test('CUR-GEN-006: Should create .cursor/rules/*.mdc files from language instructions', async () => {
      const instructionFiles = [
        {
          path: 'templates/general/copilot-instructions.md',
          content: 'General instructions',
        },
        {
          path: 'templates/typescript/typescript.instructions.md',
          content: 'TypeScript specific instructions',
        },
        {
          path: 'templates/react/react.instructions.md',
          content: 'React specific instructions',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'react'
      );

      expect(result).toHaveLength(2); // Should skip copilot-instructions.md

      const typeScriptRule = result.find(
        (r) => r.filename === 'typescript-instructions.mdc'
      );
      expect(typeScriptRule).toBeDefined();
      expect(typeScriptRule?.pattern).toBe('**/*.ts');
      expect(typeScriptRule?.content).toContain(
        'TypeScript specific instructions'
      );

      const reactRule = result.find(
        (r) => r.filename === 'react-instructions.mdc'
      );
      expect(reactRule).toBeDefined();
      expect(reactRule?.pattern).toBe('**/*.{tsx,jsx}');
      expect(reactRule?.content).toContain('React specific instructions');
    });

    test('CUR-GEN-007: Should add MDC frontmatter with glob patterns and descriptions', async () => {
      const instructionFiles = [
        {
          path: 'templates/typescript/typescript.instructions.md',
          content: 'TypeScript rules',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'typescript'
      );

      expect(result).toHaveLength(1);
      expect(result[0]!.content).toMatch(
        /^---\npatterns: \["\*\*\/\*\.ts"\]\ndescription: "AI rules for \*\*\/\*\.ts files"\n---\n\n/
      );
      expect(result[0]!.content).toContain('TypeScript rules');
    });

    test('CUR-GEN-008: Should correctly map language files to glob patterns', async () => {
      const instructionFiles = [
        {
          path: 'templates/typescript/typescript.instructions.md',
          content: 'TS content',
        },
        {
          path: 'templates/python/python.instructions.md',
          content: 'Python content',
        },
        {
          path: 'templates/react/react.instructions.md',
          content: 'React content',
        },
        {
          path: 'templates/testing/test.instructions.md',
          content: 'Test content',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'react'
      );

      const tsRule = result.find((r) => r.pattern === '**/*.ts');
      const pyRule = result.find((r) => r.pattern === '**/*.py');
      const reactRule = result.find((r) => r.pattern === '**/*.{tsx,jsx}');
      const testRule = result.find((r) => r.pattern === '**/*.test.{tsx,ts}');

      expect(tsRule).toBeDefined();
      expect(pyRule).toBeDefined();
      expect(reactRule).toBeDefined();
      expect(testRule).toBeDefined();
    });

    test('CUR-GEN-009: Should handle multiple languages', async () => {
      const instructionFiles = [
        {
          path: 'templates/typescript/typescript.instructions.md',
          content: 'TypeScript rules',
        },
        {
          path: 'templates/python/python.instructions.md',
          content: 'Python rules',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'mixed'
      );

      expect(result).toHaveLength(2);
      expect(result.map((r) => r.filename)).toContain(
        'typescript-instructions.mdc'
      );
      expect(result.map((r) => r.filename)).toContain(
        'python-instructions.mdc'
      );
    });

    test('CUR-GEN-010: Should ensure MDC files follow Cursor specification', async () => {
      const instructionFiles = [
        {
          path: 'templates/typescript/typescript.instructions.md',
          content: 'TypeScript content',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'typescript'
      );

      expect(result).toHaveLength(1);
      const mdcContent = result[0]!.content;

      // Check frontmatter format
      expect(mdcContent).toMatch(/^---\n/);
      expect(mdcContent).toMatch(/patterns: \[.*\]/);
      expect(mdcContent).toMatch(/description: ".*"/);
      expect(mdcContent).toMatch(/---\n\n/);

      // Check body contains processed content
      expect(mdcContent).toContain('Generated by metacoding v');
      expect(mdcContent).toContain('# Cursor AI Development Rules');
    });
  });

  describe('File Installation and Safety', () => {
    test('CUR-GEN-011: Should install all generated Cursor files to correct locations', async () => {
      const workflowContent = 'workflow rules content';
      const patternRules: PatternRule[] = [
        {
          filename: 'typescript.mdc',
          content: 'typescript mdc content',
          pattern: '**/*.ts',
        },
      ];

      mockFileSystemService.fileExists.mockResolvedValue(false);

      const result = await cursorService.installCursorRules(
        '/test/project',
        workflowContent,
        patternRules
      );

      expect(result.success).toBe(true);
      expect(mockFileSystemService.ensureDirectoryExists).toHaveBeenCalledWith(
        '/test/project/.cursor/rules'
      );
      expect(mockFileSystemService.writeFile).toHaveBeenCalledWith(
        '/test/project/workflow.cursorrules',
        workflowContent
      );
      expect(mockFileSystemService.writeFile).toHaveBeenCalledWith(
        '/test/project/.cursor/rules/typescript.mdc',
        'typescript mdc content'
      );
    });

    test('CUR-GEN-012: Should detect existing files that would be overwritten', async () => {
      const workflowContent = 'workflow rules content';
      const patternRules: PatternRule[] = [
        {
          filename: 'typescript.mdc',
          content: 'typescript mdc content',
          pattern: '**/*.ts',
        },
      ];

      mockFileSystemService.fileExists.mockImplementation(
        (filePath: string) => {
          if (filePath.endsWith('workflow.cursorrules'))
            return Promise.resolve(true);
          if (filePath.endsWith('typescript.mdc')) return Promise.resolve(true);
          return Promise.resolve(false);
        }
      );

      const result = await cursorService.installCursorRules(
        '/test/project',
        workflowContent,
        patternRules
      );

      expect(result.success).toBe(false);
      expect(result.conflicts).toContain('workflow.cursorrules');
      expect(result.conflicts).toContain('.cursor/rules/typescript.mdc');
    });

    test('CUR-GEN-013: Should create backup before installation', async () => {
      const projectPath = '/test/project';

      mockFileSystemService.fileExists.mockImplementation(
        (filePath: string) => {
          return Promise.resolve(filePath.endsWith('workflow.cursorrules'));
        }
      );

      mockFileSystemService.backupFile.mockResolvedValue(
        '/test/project/workflow.cursorrules.backup'
      );

      const result = await cursorService.backupExistingRules(projectPath);

      expect(result).toContain('/test/project/workflow.cursorrules.backup');
      expect(mockFileSystemService.backupFile).toHaveBeenCalledWith(
        '/test/project/workflow.cursorrules'
      );
    });

    test('CUR-GEN-014: Should respect user preferences for existing files', async () => {
      const workflowContent = 'workflow rules content';
      const patternRules: PatternRule[] = [];

      // Simulate existing file
      mockFileSystemService.fileExists.mockResolvedValue(true);

      const result = await cursorService.installCursorRules(
        '/test/project',
        workflowContent,
        patternRules
      );

      // Should not proceed with installation when conflicts exist
      expect(result.success).toBe(false);
      expect(result.conflicts.length).toBeGreaterThan(0);
      expect(mockFileSystemService.writeFile).not.toHaveBeenCalled();
    });

    test('CUR-GEN-015: Should validate file permissions', async () => {
      const workflowContent = 'workflow rules content';
      const patternRules: PatternRule[] = [];

      mockFileSystemService.fileExists.mockResolvedValue(false);
      mockFileSystemService.writeFile.mockRejectedValue(
        new Error('Permission denied')
      );

      await expect(
        cursorService.installCursorRules(
          '/test/project',
          workflowContent,
          patternRules
        )
      ).rejects.toThrow('Failed to install Cursor rules: Permission denied');
    });
  });

  describe('Cross-Platform Compatibility', () => {
    test('CUR-GEN-016: Should handle path separators correctly', () => {
      const customPath = cursorService.getCursorConfigPath(
        '/custom/path/cursor'
      );
      expect(customPath).toBe('/custom/path/cursor');

      const defaultPath = cursorService.getCursorConfigPath();
      expect(defaultPath).toBe(path.join(os.homedir(), '.cursor'));
    });

    test('CUR-GEN-017: Should generate valid files on different platforms', async () => {
      const instructionFiles = [
        {
          path: 'templates/general/copilot-instructions.md',
          content: 'Cross-platform instructions',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generateWorkflowRules(
        '/test/project',
        'general'
      );

      // Should not contain platform-specific line endings or paths
      expect(result).not.toContain('\r\n');
      expect(result).not.toContain('\\\\');
      expect(result).toContain('Cross-platform instructions');
    });

    test('CUR-GEN-018: Should handle filesystem limitations', async () => {
      const instructionFiles = [
        {
          path: 'templates/special/file-with-very-long-name-that-might-exceed-filesystem-limits.instructions.md',
          content: 'Content',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'special'
      );

      expect(result).toHaveLength(1);
      expect(result[0]!.filename.length).toBeLessThan(255); // Common filesystem limit
      expect(result[0]!.filename).toMatch(/^[a-z0-9-]+\.mdc$/); // Safe characters only
    });

    test('CUR-GEN-019: Should respect file system case sensitivity', async () => {
      const instructionFiles = [
        {
          path: 'templates/MixedCase/CamelCase.Instructions.md',
          content: 'Mixed case content',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'mixed'
      );

      expect(result).toHaveLength(1);
      expect(result[0]!.filename).toBe('camelcase-instructions.mdc'); // Should be lowercase
    });

    test('CUR-GEN-020: Should handle special characters in filenames', async () => {
      const instructionFiles = [
        {
          path: 'templates/special/file@with#special$chars%.instructions.md',
          content: 'Special chars content',
        },
      ];

      mockTemplateManager.getInstructionFiles.mockResolvedValue(
        instructionFiles
      );

      const result = await cursorService.generatePatternRules(
        '/test/project',
        'special'
      );

      expect(result).toHaveLength(1);
      expect(result[0]!.filename).toBe(
        'file-with-special-chars-instructions.mdc'
      );
      expect(result[0]!.filename).toMatch(/^[a-z0-9-]+\.mdc$/);
    });
  });
});
