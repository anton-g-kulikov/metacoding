import { InitCommand } from '../../src/commands/init';
import { FileSystemService } from '../../src/services/filesystem';
import * as fs from 'fs-extra';
import * as path from 'path';
import { describe, test, expect, beforeEach, afterEach } from '@jest/globals';

/**
 * End-to-end integration tests for Cursor IDE support
 *
 * Test suite: End-to-End Tests for Cursor IDE
 * Validates complete user workflows and cross-platform compatibility
 */
describe('End-to-End Cursor Integration Tests', () => {
  let testDir: string;
  let originalCwd: string;
  let initCommand: InitCommand;
  let fileSystem: FileSystemService;

  beforeEach(async () => {
    // Create a temporary test directory
    originalCwd = process.cwd();
    testDir = path.join(__dirname, '../../tmp-test-' + Date.now());
    await fs.ensureDir(testDir);
    process.chdir(testDir);

    // Set test environment
    process.env.NODE_ENV = 'test';

    // Initialize services
    initCommand = new InitCommand();
    fileSystem = new FileSystemService();
  });

  afterEach(async () => {
    // Clean up
    process.chdir(originalCwd);
    await fs.remove(testDir);
  });

  describe('Complete Cursor Setup Workflow', () => {
    test('E2E-CUR-001: should complete full Cursor setup for fresh TypeScript project', async () => {
      const options = {
        template: 'typescript',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify all expected files were created
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);
      expect(await fs.pathExists('.cursor/rules')).toBe(true);
      expect(await fileSystem.fileExists('.github/instructions')).toBe(true);

      // Verify workflow.cursorrules content quality
      const workflowContent = await fileSystem.readFile('workflow.cursorrules');
      expect(workflowContent).toContain('Generated by metacoding');
      expect(workflowContent).toContain('Cursor AI Development Rules');
      expect(workflowContent.length).toBeGreaterThan(1000); // Substantial content

      // Verify VS Code files were not created
      expect(await fs.pathExists('.vscode')).toBe(false);

      // Verify instruction files were still created (shared content)
      expect(
        await fileSystem.fileExists('.github/copilot-instructions.md')
      ).toBe(true);
      expect(
        await fileSystem.fileExists(
          '.github/instructions/code-review.instructions.md'
        )
      ).toBe(true);
    });

    test('E2E-CUR-002: should complete full Cursor setup for React project', async () => {
      const options = {
        template: 'react',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify React-specific setup
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);

      // Verify workflow content contains React-specific guidance
      const workflowContent = await fileSystem.readFile('workflow.cursorrules');
      expect(workflowContent).toContain('React');
      expect(workflowContent).toContain('Generated by metacoding');

      // Verify React-specific instruction files
      expect(
        await fileSystem.fileExists(
          '.github/instructions/react.coding.instructions.md'
        )
      ).toBe(true);
    });

    test('E2E-CUR-003: should handle project migration from VS Code to Cursor', async () => {
      // First, set up with VS Code
      const vscodeOptions = {
        template: 'general',
        force: true,
        skipGit: true,
        vscode: true,
      };

      await initCommand.execute(vscodeOptions);

      // Verify VS Code setup
      expect(await fs.pathExists('.vscode')).toBe(true);
      expect(
        await fileSystem.fileExists('.github/copilot-instructions.md')
      ).toBe(true);

      // Now migrate to Cursor
      const cursorOptions = {
        template: 'general',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(cursorOptions);

      // Verify Cursor files were created
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);

      // Verify both VS Code and Cursor files coexist (no conflicts)
      expect(await fs.pathExists('.vscode')).toBe(true);
      expect(
        await fileSystem.fileExists('.github/copilot-instructions.md')
      ).toBe(true);
    });

    test('E2E-CUR-004: should generate appropriate content for Python project', async () => {
      const options = {
        template: 'python',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify Python-specific setup
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);

      // Verify Python-specific content
      const workflowContent = await fileSystem.readFile('workflow.cursorrules');
      expect(workflowContent).toContain('Python');
      expect(workflowContent).toContain('Generated by metacoding');

      // Verify Python-specific instruction files
      expect(
        await fileSystem.fileExists(
          '.github/instructions/python.coding.instructions.md'
        )
      ).toBe(true);
    });
  });

  describe('Cross-Platform Compatibility', () => {
    test('E2E-CUR-005: should create valid file paths on current platform', async () => {
      const options = {
        template: 'general',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify files are accessible using platform-appropriate paths
      const workflowPath = path.join(process.cwd(), 'workflow.cursorrules');
      const cursorDir = path.join(process.cwd(), '.cursor');
      const rulesDir = path.join(process.cwd(), '.cursor', 'rules');

      expect(await fs.pathExists(workflowPath)).toBe(true);
      expect(await fs.pathExists(cursorDir)).toBe(true);
      expect(await fs.pathExists(rulesDir)).toBe(true);

      // Verify file content is readable
      const content = await fs.readFile(workflowPath, 'utf8');
      expect(content.length).toBeGreaterThan(100);
      expect(content).toMatch(/[\w\s]/); // Contains readable text
    });

    test('E2E-CUR-006: should handle special characters in project paths', async () => {
      // This test runs in the current temp directory which should be safe
      // In a real scenario, we'd test with spaces and special chars in paths

      const options = {
        template: 'general',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify files were created successfully regardless of path complexity
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);
    });
  });

  describe('User Experience Validation', () => {
    test('E2E-CUR-007: should provide meaningful file content for users', async () => {
      const options = {
        template: 'typescript',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify workflow.cursorrules contains useful guidance
      const workflowContent = await fileSystem.readFile('workflow.cursorrules');

      // Should contain essential elements for Cursor users
      expect(workflowContent).toContain('# Cursor AI Development Rules');
      expect(workflowContent).toContain('TypeScript');
      expect(workflowContent).toContain('coding standards');
      expect(workflowContent).toContain('best practices');
      expect(workflowContent).toContain('development workflow');

      // Should not contain VS Code specific content
      expect(workflowContent).not.toContain('GitHub Copilot');
      expect(workflowContent).not.toContain('.vscode');

      // Should contain metacoding attribution
      expect(workflowContent).toContain('Generated by metacoding');
      expect(workflowContent).toMatch(/v\d+\.\d+\.\d+/); // Version number
    });

    test('E2E-CUR-008: should create well-structured directory layout', async () => {
      const options = {
        template: 'react',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify logical directory structure
      const expectedDirs = [
        '.cursor',
        '.cursor/rules',
        '.github',
        '.github/instructions',
      ];

      for (const dir of expectedDirs) {
        expect(await fs.pathExists(dir)).toBe(true);
        const stats = await fs.stat(dir);
        expect(stats.isDirectory()).toBe(true);
      }

      // Verify key files exist
      const expectedFiles = [
        'workflow.cursorrules',
        '.github/copilot-instructions.md',
        '.github/instructions/code-review.instructions.md',
        '.github/instructions/react.coding.instructions.md',
      ];

      for (const file of expectedFiles) {
        expect(await fileSystem.fileExists(file)).toBe(true);
      }
    });
  });

  describe('Error Recovery and Edge Cases', () => {
    test('E2E-CUR-009: should handle empty project directory gracefully', async () => {
      // Ensure we start with a completely empty directory
      const files = await fs.readdir('.');
      expect(files.length).toBe(0);

      const options = {
        template: 'general',
        force: true,
        skipGit: true,
        cursor: true,
      };

      await initCommand.execute(options);

      // Verify setup completed successfully
      expect(await fileSystem.fileExists('workflow.cursorrules')).toBe(true);
      expect(await fs.pathExists('.cursor')).toBe(true);
    });

    test('E2E-CUR-010: should provide consistent results across multiple runs', async () => {
      const options = {
        template: 'general',
        force: true,
        skipGit: true,
        cursor: true,
      };

      // Run setup twice
      await initCommand.execute(options);
      const firstContent = await fileSystem.readFile('workflow.cursorrules');

      await initCommand.execute(options);
      const secondContent = await fileSystem.readFile('workflow.cursorrules');

      // Content should be identical (deterministic generation)
      expect(firstContent).toBe(secondContent);
    });
  });
});
